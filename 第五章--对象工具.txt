5.1 php包和命名空间，自动加载
   包的概念其实就是很多个类的一个集合，就好比我们某一个目录，这个目录可能包含很多的.php文件，只不过同一个包下面的类库具有相同的或相似的特性。
   当我们开发大型应用程序的时候，我们可能会建立很多的类，也可能会引用到第三方的类库包。那么可能就会出现类名重复的问题啦！
   ex://my.php
      require_once 'userful/a.php';
      class output{}

      //userful a.php
      class output{}

      //error notice
      Fatal error: Cannot redeclare class output in E:\wnmp\www\localhost\demon-php\test\a.php on line 2

    从php5.3开始，php出现了命名空间的概念，这个特性很好的解决了上面我们出现的问题。
    概念：命名空间就是一个容器，你可以将类，函数，变量放在其中。
    ex: namespace my;
        require_once 'userful/output.php';
        class output{}

        namespace userful;
        class output{}

    嵌套命名空间： namespace com\getinstance\util;
                   class a{
                    static public function b{
                       echo 'a';
                     }
                   } 

    如果我们在命名空间内部使用该类可直接调用：b::a();
    如果需要在外部引用该类，需要使用use关键字先引入该类或者使用全称使用。
    //my.php
    namespace my;
    class c{
      function d{
        com\getinstance\util\a::b();//这种使用相对命名空间的方式将会导致查找不到a类，相对路径的方式会从my空间开始寻找com\getinstance\util\a

        \com\getinstance\util\a::b() // 正确的调用方式，加一'/'，采用绝对路径，从全局开始寻找com\getinstance\util\a
      }
    }
    这个地方不得不说一下，刚开始我使用tp5的时候由于对概念不清晰出现的一个小bug：
    namespace app\console\controller;
    class b extends think\Controller{}
    报错之后自己还是很疑惑这怎么可能，然后看公司其他人的代码class b extends \think\Controller{}然后也没多想，就直接改成一样bug就解决了，当时也没仔细想这个问题，现在突然发现工作中的任何一个bug都是自己没有掌握的一个知识点，看来以后还是要多用点心呀。

    对于一些嵌套比较深的类，我们使用时也是比较麻烦的，\com\getinstance\util\a::b();
    这里我们可以通过use 关键字引入该命名空间，
    namespace main;
    use com\getinstance\util;
    util\a::b();
    当使用use关键字导入该命名空间时，会隐式为其使用别名util;

    显示使用别名：use com\getinstance\util\a as ua;
    对于一些全局空间的php文件可以加上'\'区分和命名空间
    listeren::a();//某命名空间下的类
    \listeren::a()//全局类